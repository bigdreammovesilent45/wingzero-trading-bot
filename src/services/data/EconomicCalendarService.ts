interface EconomicEvent {
  eventId: string;
  title: string;
  description: string;
  category: 'central_bank' | 'earnings' | 'economic_data' | 'political' | 'geopolitical' | 'corporate';
  subCategory: string;
  
  // Timing
  scheduledTime: number;
  actualTime?: number;
  timezone: string;
  duration?: number; // estimated duration in minutes
  
  // Geographic and currency impact
  country: string;
  region: 'US' | 'EU' | 'UK' | 'JP' | 'CN' | 'Global';
  currency: string;
  affectedCurrencies: string[];
  
  // Impact assessment
  importance: 'low' | 'medium' | 'high' | 'critical';
  volatilityExpected: number; // 0-100 scale
  marketImpact: {
    forex: number; // 0-100 scale
    stocks: number;
    bonds: number;
    commodities: number;
    crypto: number;
  };
  
  // Data specifics
  dataType: 'rate_decision' | 'inflation' | 'employment' | 'gdp' | 'trade' | 'manufacturing' | 'sentiment' | 'earnings';
  frequency: 'real_time' | 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'annually' | 'irregular';
  
  // Values
  previous?: number | string;
  forecast?: number | string;
  actual?: number | string;
  revised?: number | string;
  unit?: string;
  
  // Additional metadata
  source: string;
  sourceUrl?: string;
  lastUpdated: number;
  isRevised: boolean;
  revisionHistory?: Array<{
    timestamp: number;
    oldValue: any;
    newValue: any;
    reason: string;
  }>;
  
  // Market reaction tracking
  marketReaction?: {
    priceMovements: Array<{
      symbol: string;
      priceChange: number;
      percentChange: number;
      volume: number;
      timestamp: number;
    }>;
    volatilitySpike: number;
    correlatedEvents: string[];
  };
}

interface EarningsEvent extends EconomicEvent {
  company: {
    symbol: string;
    name: string;
    sector: string;
    marketCap: number;
    employees?: number;
  };
  quarter: string;
  fiscalYear: number;
  estimates: {
    epsEstimate: number;
    revenueEstimate: number;
    analystCount: number;
  };
  actual?: {
    eps: number;
    revenue: number;
    guidance?: {
      nextQuarterEps: number;
      nextQuarterRevenue: number;
      fullYearEps: number;
      fullYearRevenue: number;
    };
  };
  surprise?: {
    epsSurprise: number;
    revenueSurprise: number;
    surprisePercent: number;
  };
}

interface CentralBankEvent extends EconomicEvent {
  bank: 'fed' | 'ecb' | 'boe' | 'boj' | 'rba' | 'boc' | 'snb' | 'rbnz';
  bankName: string;
  eventType: 'rate_decision' | 'speech' | 'minutes' | 'press_conference' | 'policy_statement' | 'report';
  speaker?: string;
  speakerTitle?: string;
  currentRate?: number;
  expectedRate?: number;
  actualRate?: number;
  rateChange?: number;
  policyChanges?: Array<{
    type: string;
    description: string;
    effective: number;
  }>;
  statement?: {
    text: string;
    tone: 'dovish' | 'neutral' | 'hawkish';
    keyPoints: string[];
    marketImplications: string[];
  };
}

interface EventCalendar {
  date: string; // YYYY-MM-DD
  events: EconomicEvent[];
  importance: 'low' | 'medium' | 'high' | 'critical';
  marketSessions: Array<{
    market: string;
    openTime: number;
    closeTime: number;
    isOpen: boolean;
  }>;
  holidays: Array<{
    country: string;
    name: string;
    affectedMarkets: string[];
  }>;
}

interface EventSubscription {
  subscriptionId: string;
  filters: {
    categories?: EconomicEvent['category'][];
    importance?: EconomicEvent['importance'][];
    countries?: string[];
    currencies?: string[];
    keywords?: string[];
    timeframe?: {
      start: number;
      end: number;
    };
  };
  callback: (event: EconomicEvent) => void;
  alertCallback?: (alert: EventAlert) => void;
  isActive: boolean;
  createdAt: number;
}

interface EventAlert {
  alertId: string;
  eventId: string;
  alertType: 'upcoming' | 'released' | 'revised' | 'surprise' | 'impact';
  message: string;
  severity: 'info' | 'warning' | 'critical';
  timestamp: number;
  autoGenerated: boolean;
  marketImpact?: {
    expectedVolatility: number;
    affectedSymbols: string[];
    riskLevel: 'low' | 'medium' | 'high';
  };
}

interface EventAnalysis {
  eventId: string;
  analysisType: 'pre_event' | 'post_event' | 'impact_assessment';
  timestamp: number;
  
  // Pre-event analysis
  marketExpectations?: {
    consensus: number | string;
    range: { min: number | string; max: number | string };
    probability: number; // 0-100
    marketPositioning: string;
  };
  
  // Post-event analysis
  actualVsExpected?: {
    surprise: number;
    surpriseType: 'positive' | 'negative' | 'neutral';
    significance: 'low' | 'medium' | 'high';
  };
  
  // Market impact
  marketResponse?: {
    immediate: {
      priceChanges: Array<{ symbol: string; change: number; volume: number }>;
      volatilityIncrease: number;
      correlations: Array<{ symbol1: string; symbol2: string; correlation: number }>;
    };
    sustained: {
      trend: 'bullish' | 'bearish' | 'neutral';
      duration: number; // minutes
      reversion: boolean;
    };
  };
  
  // Historical comparison
  historicalComparison?: {
    similarEvents: string[];
    averageMarketResponse: number;
    responseRange: { min: number; max: number };
    confidence: number;
  };
}

export class EconomicCalendarService {
  private events: Map<string, EconomicEvent> = new Map();
  private calendars: Map<string, EventCalendar> = new Map(); // date -> calendar
  private subscriptions: Map<string, EventSubscription> = new Map();
  private alerts: Map<string, EventAlert> = new Map();
  private analyses: Map<string, EventAnalysis[]> = new Map(); // eventId -> analyses
  
  // Data sources
  private dataSources: Map<string, {
    name: string;
    type: 'api' | 'feed' | 'scraper';
    endpoint: string;
    credentials?: any;
    reliability: number; // 0-100
    latency: number; // milliseconds
    categories: string[];
  }> = new Map();
  
  // Real-time monitoring
  private monitoringTimers: Map<string, NodeJS.Timeout> = new Map();
  private upcomingEvents: Array<{ eventId: string; alertTime: number }> = [];
  private isMonitoring = false;
  
  // Performance metrics
  private metrics = {
    totalEvents: 0,
    eventsToday: 0,
    criticalEvents: 0,
    alertsSent: 0,
    averageLatency: 0,
    sourceReliability: new Map<string, number>(),
    lastUpdate: 0
  };

  constructor() {
    this.initializeDataSources();
  }

  async initialize(): Promise<void> {
    console.log('📅 Initializing Economic Calendar Service...');

    // Load initial calendar data
    await this.loadCalendarData();

    // Start real-time monitoring
    this.startEventMonitoring();

    // Initialize alert system
    this.setupAlertSystem();

    console.log('✅ Economic Calendar Service initialized');
  }

  // Event Management
  async addEvent(event: Omit<EconomicEvent, 'eventId' | 'lastUpdated'>): Promise<EconomicEvent> {
    const eventId = this.generateEventId();
    
    const fullEvent: EconomicEvent = {
      ...event,
      eventId,
      lastUpdated: Date.now()
    };

    console.log(`📅 Adding economic event: ${fullEvent.title}`);

    this.events.set(eventId, fullEvent);

    // Add to calendar
    const dateKey = this.getDateKey(fullEvent.scheduledTime);
    const calendar = this.calendars.get(dateKey) || this.createEmptyCalendar(dateKey);
    calendar.events.push(fullEvent);
    calendar.importance = this.calculateCalendarImportance(calendar.events);
    this.calendars.set(dateKey, calendar);

    // Schedule alerts if within monitoring window
    this.scheduleEventAlerts(fullEvent);

    // Update metrics
    this.updateMetrics();

    // Notify subscribers
    this.notifySubscribers(fullEvent);

    console.log(`✅ Event added: ${eventId}`);
    return fullEvent;
  }

  async updateEvent(eventId: string, updates: Partial<EconomicEvent>): Promise<EconomicEvent> {
    const event = this.events.get(eventId);
    if (!event) {
      throw new Error(`Event ${eventId} not found`);
    }

    console.log(`📝 Updating event: ${eventId}`);

    // Track revisions for important fields
    if (updates.actual !== undefined && updates.actual !== event.actual) {
      if (!event.revisionHistory) {
        event.revisionHistory = [];
      }
      event.revisionHistory.push({
        timestamp: Date.now(),
        oldValue: event.actual,
        newValue: updates.actual,
        reason: 'actual_value_update'
      });
      event.isRevised = true;
    }

    // Apply updates
    const updatedEvent = { ...event, ...updates, lastUpdated: Date.now() };
    this.events.set(eventId, updatedEvent);

    // Update calendar
    const dateKey = this.getDateKey(updatedEvent.scheduledTime);
    const calendar = this.calendars.get(dateKey);
    if (calendar) {
      const eventIndex = calendar.events.findIndex(e => e.eventId === eventId);
      if (eventIndex >= 0) {
        calendar.events[eventIndex] = updatedEvent;
        calendar.importance = this.calculateCalendarImportance(calendar.events);
        this.calendars.set(dateKey, calendar);
      }
    }

    // Generate revision alert if significant
    if (event.isRevised && event.importance === 'critical') {
      await this.generateAlert(eventId, 'revised', `Critical event revised: ${event.title}`, 'critical');
    }

    // Notify subscribers
    this.notifySubscribers(updatedEvent);

    console.log(`✅ Event updated: ${eventId}`);
    return updatedEvent;
  }

  // Event Queries
  getEvent(eventId: string): EconomicEvent | undefined {
    return this.events.get(eventId);
  }

  getEventsForDate(date: string): EconomicEvent[] {
    const calendar = this.calendars.get(date);
    return calendar ? calendar.events : [];
  }

  getEventsInRange(startDate: number, endDate: number): EconomicEvent[] {
    const events: EconomicEvent[] = [];
    
    for (const event of this.events.values()) {
      if (event.scheduledTime >= startDate && event.scheduledTime <= endDate) {
        events.push(event);
      }
    }
    
    return events.sort((a, b) => a.scheduledTime - b.scheduledTime);
  }

  getUpcomingEvents(hours: number = 24): EconomicEvent[] {
    const now = Date.now();
    const cutoff = now + (hours * 60 * 60 * 1000);
    
    return this.getEventsInRange(now, cutoff);
  }

  getCriticalEvents(days: number = 7): EconomicEvent[] {
    const now = Date.now();
    const cutoff = now + (days * 24 * 60 * 60 * 1000);
    
    return this.getEventsInRange(now, cutoff)
      .filter(event => event.importance === 'critical');
  }

  getEventsByCategory(category: EconomicEvent['category'], days: number = 30): EconomicEvent[] {
    const now = Date.now();
    const cutoff = now + (days * 24 * 60 * 60 * 1000);
    
    return this.getEventsInRange(now, cutoff)
      .filter(event => event.category === category);
  }

  getEventsByCurrency(currency: string, days: number = 7): EconomicEvent[] {
    const now = Date.now();
    const cutoff = now + (days * 24 * 60 * 60 * 1000);
    
    return this.getEventsInRange(now, cutoff)
      .filter(event => 
        event.currency === currency || 
        event.affectedCurrencies.includes(currency)
      );
  }

  // Specialized Event Queries
  getCentralBankEvents(bank?: CentralBankEvent['bank'], days: number = 30): CentralBankEvent[] {
    const events = this.getEventsByCategory('central_bank', days) as CentralBankEvent[];
    
    if (bank) {
      return events.filter(event => event.bank === bank);
    }
    
    return events;
  }

  getEarningsEvents(sector?: string, days: number = 30): EarningsEvent[] {
    const events = this.getEventsByCategory('earnings', days) as EarningsEvent[];
    
    if (sector) {
      return events.filter(event => event.company.sector === sector);
    }
    
    return events;
  }

  getHighImpactEvents(threshold: number = 70, days: number = 7): EconomicEvent[] {
    const now = Date.now();
    const cutoff = now + (days * 24 * 60 * 60 * 1000);
    
    return this.getEventsInRange(now, cutoff)
      .filter(event => event.volatilityExpected >= threshold);
  }

  // Subscription Management
  async subscribe(
    filters: EventSubscription['filters'],
    callback: EventSubscription['callback'],
    alertCallback?: EventSubscription['alertCallback']
  ): Promise<string> {
    const subscriptionId = this.generateSubscriptionId();
    
    console.log(`📊 Creating calendar subscription: ${subscriptionId}`);

    const subscription: EventSubscription = {
      subscriptionId,
      filters,
      callback,
      alertCallback,
      isActive: true,
      createdAt: Date.now()
    };

    this.subscriptions.set(subscriptionId, subscription);

    // Send recent matching events
    const recentEvents = this.getEventsInRange(Date.now(), Date.now() + 24 * 60 * 60 * 1000);
    for (const event of recentEvents) {
      if (this.eventMatchesFilters(event, filters)) {
        callback(event);
      }
    }

    console.log(`✅ Calendar subscription created: ${subscriptionId}`);
    return subscriptionId;
  }

  async unsubscribe(subscriptionId: string): Promise<void> {
    const subscription = this.subscriptions.get(subscriptionId);
    if (!subscription) {
      throw new Error(`Subscription ${subscriptionId} not found`);
    }

    console.log(`🔌 Unsubscribing from calendar: ${subscriptionId}`);

    subscription.isActive = false;
    this.subscriptions.delete(subscriptionId);

    console.log(`✅ Calendar subscription removed: ${subscriptionId}`);
  }

  // Alert System
  private setupAlertSystem(): void {
    // Check for upcoming events every minute
    setInterval(() => {
      this.checkUpcomingEvents();
    }, 60000);

    // Check for event releases every 30 seconds
    setInterval(() => {
      this.checkEventReleases();
    }, 30000);

    console.log('🚨 Alert system activated');
  }

  private async checkUpcomingEvents(): Promise<void> {
    const now = Date.now();
    const upcomingWindow = 60 * 60 * 1000; // 1 hour
    
    const upcomingEvents = this.getEventsInRange(now, now + upcomingWindow);
    
    for (const event of upcomingEvents) {
      const timeToEvent = event.scheduledTime - now;
      
      // Generate alerts at specific intervals
      if (this.shouldGenerateUpcomingAlert(event, timeToEvent)) {
        await this.generateAlert(
          event.eventId,
          'upcoming',
          this.formatUpcomingAlert(event, timeToEvent),
          this.getAlertSeverity(event)
        );
      }
    }
  }

  private async checkEventReleases(): Promise<void> {
    const now = Date.now();
    const releaseWindow = 10 * 60 * 1000; // 10 minutes
    
    // Check events scheduled in the last 10 minutes
    const recentEvents = this.getEventsInRange(now - releaseWindow, now);
    
    for (const event of recentEvents) {
      if (event.actual !== undefined && !event.marketReaction) {
        // Event has been released but no market reaction tracked yet
        await this.analyzeEventImpact(event);
        await this.generateAlert(
          event.eventId,
          'released',
          `Event released: ${event.title} - Actual: ${event.actual}`,
          this.getAlertSeverity(event)
        );
      }
    }
  }

  private shouldGenerateUpcomingAlert(event: EconomicEvent, timeToEvent: number): boolean {
    const alertIntervals = [
      24 * 60 * 60 * 1000, // 24 hours
      4 * 60 * 60 * 1000,  // 4 hours
      60 * 60 * 1000,      // 1 hour
      15 * 60 * 1000       // 15 minutes
    ];

    return alertIntervals.some(interval => 
      Math.abs(timeToEvent - interval) < 60000 // Within 1 minute of alert time
    );
  }

  private formatUpcomingAlert(event: EconomicEvent, timeToEvent: number): string {
    const hours = Math.floor(timeToEvent / (60 * 60 * 1000));
    const minutes = Math.floor((timeToEvent % (60 * 60 * 1000)) / (60 * 1000));
    
    if (hours > 0) {
      return `${event.title} in ${hours}h ${minutes}m - ${event.importance.toUpperCase()} impact expected`;
    } else {
      return `${event.title} in ${minutes}m - ${event.importance.toUpperCase()} impact expected`;
    }
  }

  private getAlertSeverity(event: EconomicEvent): EventAlert['severity'] {
    switch (event.importance) {
      case 'critical': return 'critical';
      case 'high': return 'warning';
      default: return 'info';
    }
  }

  private async generateAlert(
    eventId: string,
    alertType: EventAlert['alertType'],
    message: string,
    severity: EventAlert['severity']
  ): Promise<void> {
    const alertId = this.generateAlertId();
    const event = this.events.get(eventId);
    
    const alert: EventAlert = {
      alertId,
      eventId,
      alertType,
      message,
      severity,
      timestamp: Date.now(),
      autoGenerated: true,
      marketImpact: event ? {
        expectedVolatility: event.volatilityExpected,
        affectedSymbols: this.getAffectedSymbols(event),
        riskLevel: this.calculateRiskLevel(event)
      } : undefined
    };

    this.alerts.set(alertId, alert);
    this.metrics.alertsSent++;

    // Notify subscribers
    this.notifyAlertSubscribers(alert);

    console.log(`🚨 Alert generated: ${alertType} - ${message}`);
  }

  private getAffectedSymbols(event: EconomicEvent): string[] {
    const symbols: string[] = [];
    
    // Add currency pairs
    for (const currency of event.affectedCurrencies) {
      symbols.push(`${currency}USD`, `EUR${currency}`, `GBP${currency}`);
    }
    
    // Add indices based on region
    switch (event.region) {
      case 'US':
        symbols.push('SPY', 'QQQ', 'DIA');
        break;
      case 'EU':
        symbols.push('EWZ', 'FEZ', 'IEUR');
        break;
      case 'UK':
        symbols.push('EWU', 'FKU');
        break;
      case 'JP':
        symbols.push('EWJ', 'DXJ');
        break;
    }
    
    return symbols;
  }

  private calculateRiskLevel(event: EconomicEvent): 'low' | 'medium' | 'high' {
    if (event.importance === 'critical' && event.volatilityExpected > 80) return 'high';
    if (event.importance === 'high' || event.volatilityExpected > 60) return 'medium';
    return 'low';
  }

  // Event Analysis
  async analyzeEvent(eventId: string, analysisType: EventAnalysis['analysisType']): Promise<EventAnalysis> {
    const event = this.events.get(eventId);
    if (!event) {
      throw new Error(`Event ${eventId} not found`);
    }

    console.log(`📊 Analyzing event: ${eventId} - ${analysisType}`);

    const analysis: EventAnalysis = {
      eventId,
      analysisType,
      timestamp: Date.now()
    };

    switch (analysisType) {
      case 'pre_event':
        analysis.marketExpectations = await this.analyzeMarketExpectations(event);
        break;
      case 'post_event':
        analysis.actualVsExpected = this.analyzeActualVsExpected(event);
        break;
      case 'impact_assessment':
        analysis.marketResponse = await this.analyzeMarketResponse(event);
        analysis.historicalComparison = await this.getHistoricalComparison(event);
        break;
    }

    // Store analysis
    if (!this.analyses.has(eventId)) {
      this.analyses.set(eventId, []);
    }
    this.analyses.get(eventId)!.push(analysis);

    console.log(`✅ Event analysis completed: ${eventId}`);
    return analysis;
  }

  private async analyzeMarketExpectations(event: EconomicEvent): Promise<EventAnalysis['marketExpectations']> {
    // Mock implementation - in production would analyze market positioning, options flow, etc.
    return {
      consensus: event.forecast || 'N/A',
      range: { min: 'N/A', max: 'N/A' },
      probability: 75,
      marketPositioning: 'Neutral to slightly bullish positioning observed'
    };
  }

  private analyzeActualVsExpected(event: EconomicEvent): EventAnalysis['actualVsExpected'] {
    if (event.actual === undefined || event.forecast === undefined) {
      return undefined;
    }

    const actual = typeof event.actual === 'number' ? event.actual : parseFloat(event.actual.toString());
    const forecast = typeof event.forecast === 'number' ? event.forecast : parseFloat(event.forecast.toString());
    
    const surprise = actual - forecast;
    const surprisePercent = Math.abs(surprise / forecast) * 100;
    
    return {
      surprise,
      surpriseType: surprise > 0 ? 'positive' : surprise < 0 ? 'negative' : 'neutral',
      significance: surprisePercent > 20 ? 'high' : surprisePercent > 5 ? 'medium' : 'low'
    };
  }

  private async analyzeMarketResponse(event: EconomicEvent): Promise<EventAnalysis['marketResponse']> {
    // Mock implementation - in production would analyze actual market data
    const affectedSymbols = this.getAffectedSymbols(event);
    
    return {
      immediate: {
        priceChanges: affectedSymbols.slice(0, 5).map(symbol => ({
          symbol,
          change: (Math.random() - 0.5) * 2, // ±1% change
          volume: Math.random() * 1000000
        })),
        volatilityIncrease: Math.random() * 50 + 10, // 10-60% increase
        correlations: []
      },
      sustained: {
        trend: ['bullish', 'bearish', 'neutral'][Math.floor(Math.random() * 3)] as any,
        duration: Math.random() * 120 + 30, // 30-150 minutes
        reversion: Math.random() > 0.7 // 30% chance of reversion
      }
    };
  }

  private async getHistoricalComparison(event: EconomicEvent): Promise<EventAnalysis['historicalComparison']> {
    // Mock implementation - in production would query historical database
    return {
      similarEvents: [],
      averageMarketResponse: Math.random() * 2 - 1, // ±1%
      responseRange: { min: -3, max: 3 },
      confidence: 70 + Math.random() * 20 // 70-90% confidence
    };
  }

  private async analyzeEventImpact(event: EconomicEvent): Promise<void> {
    // Analyze immediate market impact and store in event
    const marketReaction = await this.analyzeMarketResponse(event);
    
    event.marketReaction = {
      priceMovements: marketReaction.immediate?.priceChanges || [],
      volatilitySpike: marketReaction.immediate?.volatilityIncrease || 0,
      correlatedEvents: []
    };

    this.events.set(event.eventId, event);
  }

  // Event Monitoring
  private startEventMonitoring(): void {
    if (this.isMonitoring) return;

    this.isMonitoring = true;
    
    // Monitor upcoming events
    const monitoringInterval = setInterval(() => {
      this.updateUpcomingEvents();
    }, 5 * 60 * 1000); // Every 5 minutes

    this.monitoringTimers.set('upcoming', monitoringInterval);

    // Load real-time data
    this.startDataFeeds();

    console.log('👀 Event monitoring started');
  }

  private updateUpcomingEvents(): void {
    const now = Date.now();
    const monitoringWindow = 2 * 60 * 60 * 1000; // 2 hours
    
    this.upcomingEvents = this.getEventsInRange(now, now + monitoringWindow)
      .map(event => ({
        eventId: event.eventId,
        alertTime: event.scheduledTime - 15 * 60 * 1000 // 15 minutes before
      }))
      .filter(item => item.alertTime > now)
      .sort((a, b) => a.alertTime - b.alertTime);
  }

  private async startDataFeeds(): Promise<void> {
    // Initialize connections to economic data sources
    for (const [sourceId, source] of this.dataSources.entries()) {
      try {
        await this.connectToDataSource(sourceId);
        console.log(`📡 Connected to data source: ${source.name}`);
      } catch (error) {
        console.error(`❌ Failed to connect to ${source.name}:`, error);
      }
    }
  }

  private async connectToDataSource(sourceId: string): Promise<void> {
    const source = this.dataSources.get(sourceId);
    if (!source) return;

    // Mock connection - in production would establish real connections
    const mockData = this.generateMockEconomicData(sourceId);
    
    // Simulate real-time updates
    setInterval(() => {
      const event = this.generateMockEconomicEvent(sourceId);
      this.processIncomingEvent(event);
    }, Math.random() * 300000 + 300000); // 5-10 minutes
  }

  private async processIncomingEvent(event: EconomicEvent): Promise<void> {
    try {
      // Check if event already exists
      const existingEvent = Array.from(this.events.values())
        .find(e => e.title === event.title && e.scheduledTime === event.scheduledTime);

      if (existingEvent) {
        // Update existing event
        await this.updateEvent(existingEvent.eventId, event);
      } else {
        // Add new event
        await this.addEvent(event);
      }
    } catch (error) {
      console.error('❌ Error processing incoming event:', error);
    }
  }

  // Data Loading and Initialization
  private async loadCalendarData(): Promise<void> {
    console.log('📅 Loading initial calendar data...');

    // Load next 30 days of events
    const events = this.generateInitialEvents();
    
    for (const event of events) {
      await this.addEvent(event);
    }

    console.log(`✅ Loaded ${events.length} initial events`);
  }

  private generateInitialEvents(): Omit<EconomicEvent, 'eventId' | 'lastUpdated'>[] {
    const events: Omit<EconomicEvent, 'eventId' | 'lastUpdated'>[] = [];
    const now = Date.now();
    
    // Generate some sample events for the next 30 days
    const eventTemplates = [
      {
        title: 'Fed Interest Rate Decision',
        category: 'central_bank' as const,
        subCategory: 'monetary_policy',
        importance: 'critical' as const,
        country: 'US',
        region: 'US' as const,
        currency: 'USD',
        affectedCurrencies: ['USD', 'EUR', 'GBP', 'JPY'],
        volatilityExpected: 85,
        marketImpact: { forex: 95, stocks: 80, bonds: 90, commodities: 60, crypto: 70 },
        dataType: 'rate_decision' as const,
        frequency: 'irregular' as const
      },
      {
        title: 'US Non-Farm Payrolls',
        category: 'economic_data' as const,
        subCategory: 'employment',
        importance: 'critical' as const,
        country: 'US',
        region: 'US' as const,
        currency: 'USD',
        affectedCurrencies: ['USD', 'EUR', 'GBP', 'CAD'],
        volatilityExpected: 75,
        marketImpact: { forex: 85, stocks: 70, bonds: 75, commodities: 40, crypto: 50 },
        dataType: 'employment' as const,
        frequency: 'monthly' as const
      },
      {
        title: 'ECB Interest Rate Decision',
        category: 'central_bank' as const,
        subCategory: 'monetary_policy',
        importance: 'critical' as const,
        country: 'EU',
        region: 'EU' as const,
        currency: 'EUR',
        affectedCurrencies: ['EUR', 'USD', 'GBP', 'CHF'],
        volatilityExpected: 80,
        marketImpact: { forex: 90, stocks: 75, bonds: 85, commodities: 55, crypto: 65 },
        dataType: 'rate_decision' as const,
        frequency: 'irregular' as const
      }
    ];

    // Generate events for next 30 days
    for (let i = 0; i < 30; i++) {
      const dayOffset = i * 24 * 60 * 60 * 1000;
      
      if (Math.random() > 0.7) { // 30% chance of event each day
        const template = eventTemplates[Math.floor(Math.random() * eventTemplates.length)];
        const scheduledTime = now + dayOffset + Math.random() * 16 * 60 * 60 * 1000; // Random time during market hours
        
        events.push({
          ...template,
          description: `${template.title} scheduled for ${new Date(scheduledTime).toLocaleDateString()}`,
          scheduledTime,
          timezone: 'EST',
          source: 'economic_calendar_api',
          isRevised: false,
          forecast: Math.random() * 10,
          previous: Math.random() * 10
        });
      }
    }

    return events;
  }

  // Utility Methods
  private eventMatchesFilters(event: EconomicEvent, filters: EventSubscription['filters']): boolean {
    if (filters.categories && !filters.categories.includes(event.category)) return false;
    if (filters.importance && !filters.importance.includes(event.importance)) return false;
    if (filters.countries && !filters.countries.includes(event.country)) return false;
    if (filters.currencies && !filters.currencies.some(c => 
      event.currency === c || event.affectedCurrencies.includes(c)
    )) return false;
    if (filters.keywords && !filters.keywords.some(k => 
      event.title.toLowerCase().includes(k.toLowerCase()) ||
      event.description.toLowerCase().includes(k.toLowerCase())
    )) return false;
    if (filters.timeframe) {
      if (event.scheduledTime < filters.timeframe.start || 
          event.scheduledTime > filters.timeframe.end) return false;
    }
    
    return true;
  }

  private notifySubscribers(event: EconomicEvent): void {
    for (const subscription of this.subscriptions.values()) {
      if (!subscription.isActive) continue;
      
      if (this.eventMatchesFilters(event, subscription.filters)) {
        try {
          subscription.callback(event);
        } catch (error) {
          console.error(`❌ Error in subscription callback for ${subscription.subscriptionId}:`, error);
        }
      }
    }
  }

  private notifyAlertSubscribers(alert: EventAlert): void {
    for (const subscription of this.subscriptions.values()) {
      if (!subscription.isActive || !subscription.alertCallback) continue;
      
      try {
        subscription.alertCallback(alert);
      } catch (error) {
        console.error(`❌ Error in alert callback for ${subscription.subscriptionId}:`, error);
      }
    }
  }

  private scheduleEventAlerts(event: EconomicEvent): void {
    const now = Date.now();
    const eventTime = event.scheduledTime;
    
    // Schedule alerts at different intervals before the event
    const alertIntervals = [
      24 * 60 * 60 * 1000, // 24 hours
      4 * 60 * 60 * 1000,  // 4 hours
      60 * 60 * 1000,      // 1 hour
      15 * 60 * 1000       // 15 minutes
    ];

    for (const interval of alertIntervals) {
      const alertTime = eventTime - interval;
      if (alertTime > now) {
        setTimeout(() => {
          this.generateAlert(
            event.eventId,
            'upcoming',
            this.formatUpcomingAlert(event, interval),
            this.getAlertSeverity(event)
          );
        }, alertTime - now);
      }
    }
  }

  private getDateKey(timestamp: number): string {
    return new Date(timestamp).toISOString().split('T')[0];
  }

  private createEmptyCalendar(date: string): EventCalendar {
    return {
      date,
      events: [],
      importance: 'low',
      marketSessions: this.getMarketSessions(date),
      holidays: this.getHolidays(date)
    };
  }

  private getMarketSessions(date: string): EventCalendar['marketSessions'] {
    // Mock market sessions - in production would use real market data
    return [
      { market: 'NYSE', openTime: 1400, closeTime: 2100, isOpen: true },
      { market: 'LSE', openTime: 800, closeTime: 1630, isOpen: true },
      { market: 'TSE', openTime: 0, closeTime: 630, isOpen: true }
    ];
  }

  private getHolidays(date: string): EventCalendar['holidays'] {
    // Mock holidays - in production would use holiday calendar API
    return [];
  }

  private calculateCalendarImportance(events: EconomicEvent[]): EventCalendar['importance'] {
    if (events.some(e => e.importance === 'critical')) return 'critical';
    if (events.some(e => e.importance === 'high')) return 'high';
    if (events.some(e => e.importance === 'medium')) return 'medium';
    return 'low';
  }

  private updateMetrics(): void {
    this.metrics.totalEvents = this.events.size;
    this.metrics.eventsToday = this.getEventsForDate(this.getDateKey(Date.now())).length;
    this.metrics.criticalEvents = Array.from(this.events.values())
      .filter(e => e.importance === 'critical').length;
    this.metrics.lastUpdate = Date.now();
  }

  private initializeDataSources(): void {
    // Economic Calendar APIs
    this.dataSources.set('trading_economics', {
      name: 'Trading Economics',
      type: 'api',
      endpoint: 'https://api.tradingeconomics.com/calendar',
      reliability: 90,
      latency: 500,
      categories: ['central_bank', 'economic_data']
    });

    this.dataSources.set('forex_factory', {
      name: 'Forex Factory',
      type: 'scraper',
      endpoint: 'https://www.forexfactory.com/calendar',
      reliability: 85,
      latency: 1000,
      categories: ['central_bank', 'economic_data']
    });

    this.dataSources.set('earnings_whispers', {
      name: 'Earnings Whispers',
      type: 'api',
      endpoint: 'https://api.earningswhispers.com/calendar',
      reliability: 95,
      latency: 200,
      categories: ['earnings']
    });

    console.log(`📡 Initialized ${this.dataSources.size} data sources`);
  }

  private generateMockEconomicData(sourceId: string): any {
    // Generate mock data based on source
    return {
      sourceId,
      timestamp: Date.now(),
      events: []
    };
  }

  private generateMockEconomicEvent(sourceId: string): EconomicEvent {
    const titles = [
      'Consumer Price Index',
      'Producer Price Index',
      'Retail Sales',
      'Industrial Production',
      'Business Confidence',
      'Consumer Confidence'
    ];

    const countries = ['US', 'EU', 'UK', 'JP', 'CA', 'AU'];
    const country = countries[Math.floor(Math.random() * countries.length)];
    const title = titles[Math.floor(Math.random() * titles.length)];

    return {
      eventId: '', // Will be set when added
      title: `${country} ${title}`,
      description: `Monthly ${title} data release`,
      category: 'economic_data',
      subCategory: 'inflation',
      scheduledTime: Date.now() + Math.random() * 7 * 24 * 60 * 60 * 1000, // Next 7 days
      timezone: 'EST',
      country,
      region: country as any,
      currency: country === 'US' ? 'USD' : country === 'EU' ? 'EUR' : 'USD',
      affectedCurrencies: ['USD', 'EUR'],
      importance: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)] as any,
      volatilityExpected: Math.random() * 60 + 20, // 20-80
      marketImpact: {
        forex: Math.random() * 80 + 20,
        stocks: Math.random() * 60 + 20,
        bonds: Math.random() * 70 + 20,
        commodities: Math.random() * 50 + 10,
        crypto: Math.random() * 40 + 10
      },
      dataType: 'inflation',
      frequency: 'monthly',
      previous: Math.random() * 5,
      forecast: Math.random() * 5,
      source: sourceId,
      lastUpdated: Date.now(),
      isRevised: false
    };
  }

  // ID Generators
  private generateEventId(): string {
    return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
  }

  private generateSubscriptionId(): string {
    return `sub_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
  }

  private generateAlertId(): string {
    return `alert_${Date.now()}_${Math.random().toString(36).substr(2, 8)}`;
  }

  // Public API
  getCalendar(date: string): EventCalendar | undefined {
    return this.calendars.get(date);
  }

  getCalendarRange(startDate: string, endDate: string): EventCalendar[] {
    const calendars: EventCalendar[] = [];
    const start = new Date(startDate);
    const end = new Date(endDate);
    
    for (let d = start; d <= end; d.setDate(d.getDate() + 1)) {
      const dateKey = this.getDateKey(d.getTime());
      const calendar = this.calendars.get(dateKey);
      if (calendar) {
        calendars.push(calendar);
      }
    }
    
    return calendars;
  }

  getEventAnalyses(eventId: string): EventAnalysis[] {
    return this.analyses.get(eventId) || [];
  }

  getAlerts(severity?: EventAlert['severity']): EventAlert[] {
    const alerts = Array.from(this.alerts.values());
    return severity ? alerts.filter(a => a.severity === severity) : alerts;
  }

  getMetrics() {
    return { ...this.metrics };
  }

  async shutdown(): Promise<void> {
    console.log('🛑 Shutting down Economic Calendar Service...');

    this.isMonitoring = false;

    // Clear all timers
    for (const timer of this.monitoringTimers.values()) {
      clearInterval(timer);
    }

    // Clear all data
    this.events.clear();
    this.calendars.clear();
    this.subscriptions.clear();
    this.alerts.clear();
    this.analyses.clear();
    this.dataSources.clear();
    this.monitoringTimers.clear();

    console.log('✅ Economic Calendar Service shutdown complete');
  }
}